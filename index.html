<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>단어 반복 학습 프로그램 (Canvas 방식)</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --light-gray: #f5f5f5;
            --dark-gray: #333;
            --border-color: #ddd;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f9f9f9;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .day-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .spinner-container {
            display: flex;
            align-items: center;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        
        #daySelector {
            width: 50px;
            text-align: center;
            border: none;
            padding: 5px;
            -moz-appearance: textfield;
        }
        
        #daySelector::-webkit-inner-spin-button, 
        #daySelector::-webkit-outer-spin-button { 
            -webkit-appearance: none;
            margin: 0;
        }
        
        .spinner-btn {
            background-color: var(--light-gray);
            border: none;
            padding: 5px 8px;
            cursor: pointer;
            user-select: none;
        }
        
        .spinner-btn:hover {
            background-color: #e0e0e0;
        }
        
        button {
            padding: 8px 12px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        button:hover:not(:disabled) {
            background-color: var(--secondary-color);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .task-section {
            background-color: white;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .task-section h2 {
            margin-bottom: 10px;
            font-size: 18px;
            color: var(--dark-gray);
        }
        
        .task-list {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .task-item {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }
        
        .task-item:last-child {
            border-bottom: none;
        }
        
        .task-item.selected {
            background-color: var(--light-gray);
        }
        
        .display-section {
            background-color: white;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .word-display {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .meaning-display {
            font-size: 32px;
            text-align: center;
            min-height: 80px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .controls-section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .filter-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-grow: 1;
        }
        
        .filter-timer {
            min-width: 50px;
            text-align: center;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            align-self: center;
        }
        
        .session-buttons {
            display: flex;
            gap: 10px;
        }
        
        #pauseButton {
            background-color: var(--warning-color);
        }
        
        #pauseButton:hover:not(:disabled) {
            background-color: #e67e22;
        }
        
        #stopButton {
            background-color: var(--danger-color);
        }
        
        #stopButton:hover:not(:disabled) {
            background-color: #c0392b;
        }
        
        #pButton {
            background-color: var(--warning-color);
        }
        
        #qButton {
            background-color: var(--danger-color);
        }
        
        #knowButton {
            background-color: var(--success-color);
        }
        
        #memorizedButton {
            background-color: #9b59b6;
        }
        
        .status-bar {
            background-color: var(--light-gray);
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .config-section {
            background-color: white;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .file-section {
            margin-bottom: 20px;
        }
        
        .file-upload {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
        }
        
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        
        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }
        
        .dropdown:hover .dropdown-content {
            display: block;
        }
        
        .hidden {
            display: none !important;
        }
        
        .config-item {
            margin-bottom: 15px;
        }
        
        .config-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 200px;
        }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 50%;
            max-width: 500px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .modal-close:hover {
            color: black;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="day-selector">
                <label for="daySelector">학습 일차:</label>
                <div class="spinner-container">
                    <button class="spinner-btn" id="daySelectorDown">-</button>
                    <input type="number" id="daySelector" min="1" value="1">
                    <button class="spinner-btn" id="daySelectorUp">+</button>
                </div>
                <button id="progressDayButton">다음 날짜로 진행</button>
            </div>
            
            <div class="dropdown">
                <button id="fileButton">파일</button>
                <div class="dropdown-content">
                    <a href="#" id="loadCsvButton">CSV 불러오기</a>
                    <a href="#" id="saveProgressButton">학습 내용 저장</a>
                    <a href="#" id="loadProgressButton">학습 내용 불러오기</a>
                    <a href="#" id="exportProgressButton">학습 내용 내보내기 (CSV)</a>
                </div>
            </div>
        </header>
        
        <section class="task-section">
            <h2>오늘의 학습 계획 (Task List)</h2>
            <div class="task-list" id="taskList">
                <!-- 작업 목록이 여기에 동적으로 추가됩니다 -->
                <div class="task-item">Day 1: 예정된 작업 없음</div>
            </div>
            <button id="startTaskButton" disabled>선택 작업 시작</button>
        </section>
        
        <section class="display-section">
            <div class="word-display" id="wordDisplay"></div>
            <div class="meaning-display hidden" id="meaningDisplay"></div>
        </section>
        
        <section class="controls-section">
            <div class="filter-buttons hidden" id="filterButtons">
                <button id="pButton" disabled>P (모름/헷갈림)</button>
                <button id="qButton" disabled>Q (아주 어려움)</button>
                <button id="knowButton" disabled>✓ (확실히 앎)</button>
                <button id="memorizedButton" disabled>★ 암기 완료 ★</button>
                <div class="filter-timer" id="filterTimer"></div>
            </div>
            
            <div class="session-buttons">
                <button id="pauseButton" disabled>일시정지</button>
                <button id="stopButton" disabled>중지</button>
            </div>
        </section>
        
        <div class="status-bar" id="statusBar">상태: 준비됨</div>
        
        <section class="config-section">
            <div class="config-item">
                <label for="wordTimeSelect">단어 표시 시간:</label>
                <select id="wordTimeSelect">
                    <option value="2">2 초</option>
                    <option value="3">3 초</option>
                </select>
            </div>
        </section>
    </div>
    
    <!-- 파일 업로드용 숨겨진 input -->
    <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
    <input type="file" id="progressFileInput" accept=".json" style="display: none;">
    
    <!-- 알림 모달 -->
    <div id="alertModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="alertTitle">알림</h2>
                <span class="modal-close" id="alertClose">&times;</span>
            </div>
            <div class="modal-body">
                <p id="alertMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="alertOkButton">확인</button>
            </div>
        </div>
    </div>
    
    <!-- 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="confirmTitle">확인</h2>
                <span class="modal-close" id="confirmClose">&times;</span>
            </div>
            <div class="modal-body">
                <p id="confirmMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="confirmCancelButton">취소</button>
                <button id="confirmOkButton">확인</button>
            </div>
        </div>
    </div>
    
    <!-- 메인 자바스크립트 -->
    <script>
        // --- 상수 정의 ---
        const DEFAULT_WORD_TIME_SEC = 2; // 기본 단어 표시 시간 (초)
        const MEANING_DELAY_SEC = 1.5; // 뜻 표시 전 딜레이 (초)
        const MEANING_SHOW_SEC = 2; // 뜻 표시 유지 시간 (초)
        const FILTER_TIMEOUT_SEC = 3; // P/Q 분류 선택 제한 시간 (초)
        const WORDS_PER_SET = 100; // 세트당 단어 수
        
        // --- 애플리케이션 클래스 정의 ---
        class VocabLearnerApp {
            constructor() {
                // --- 데이터 저장소 ---
                this.all_words = []; // List of objects: {id: int, word: str, meaning: str}
                this.sets = {}; // Map: {'D1': {word_ids: [], status: 'new/learning/...'}, ...}
                this.mastered_all_ids = new Set(); // Set of word IDs fully mastered
                this.q_all_ids = new Set(); // Set of word IDs currently in Q status across all sets
                this.current_day = 1; // 프로그램의 현재 기준 일차
                this.word_display_time_sec = DEFAULT_WORD_TIME_SEC;
                this.meaning_delay_sec = MEANING_DELAY_SEC;
                this.meaning_show_sec = MEANING_SHOW_SEC;
                
                // --- 상태 변수 ---
                this.current_session_type = null; // 'learn', 'learn_p', 'learn_q', 'p_filter', 'q_filter'
                this.current_set_key = null;
                this.current_word_list = []; // List of word objects for the current session
                this.current_word_index = -1; // 현재 단어 인덱스 (-1은 시작 전)
                this.session_running = false;
                this.session_paused = false;
                this.timer_word_delay = null;
                this.timer_meaning_delay = null;
                this.timer_next_word = null;
                this.timer_filter_timeout = null;
                
                // --- P/Q 필터링 관련 상태 ---
                this.current_filter_candidates = []; // 필터링 대상 단어 ID 목록
                this.current_filter_temp_keep = []; // 현재 필터링 세션에서 'Keep'으로 표시된 단어 ID 목록
                this.filter_start_time = 0; // 필터링 단어 표시 시작 시간
                this.is_waiting_for_filter_choice = false; // 필터링 선택 대기 중 여부
                
                // --- word_dict_cache 설정 ---
                this._word_dict_cache = {};
                
                // --- 요소 참조 설정 ---
                this.initElements();
                
                // --- 이벤트 리스너 설정 ---
                this.initEventListeners();
                
                // --- 빈 상태 초기화 ---
                this.initialize_empty_state();
                this.update_day_selector();
                this.update_status_bar();
                this.update_task_list();
                
                // 자동저장 체크 - localStorage 대신 입력 포맷데이터를 기준으로 확인
                const queryParams = new URLSearchParams(window.location.search);
                if(queryParams.has("autoload")) {
                    // URL에 autoload 파라미터가 있으면 저장 데이터 확인
                    try {
                        // 현재 페이지 URL의 fragment를 확인 (#로 시작하는 부분)
                        const fragment = window.location.hash;
                        if(fragment && fragment.length > 1) {
                            // #을 제외한 부분을 디코딩하여 데이터로 변환
                            const encodedData = fragment.substring(1);
                            const jsonData = decodeURIComponent(encodedData);
                            this.loadProgressData(jsonData);
                            console.log("URL에서 자동으로 데이터를 로드했습니다.");
                        }
                    } catch(e) {
                        console.error("URL에서 데이터 로드 실패:", e);
                    }
                }
            }
            
            initElements() {
                // --- 각 요소 참조 저장 ---
                this.elements = {
                    daySelector: document.getElementById('daySelector'),
                    daySelectorUp: document.getElementById('daySelectorUp'),
                    daySelectorDown: document.getElementById('daySelectorDown'),
                    progressDayButton: document.getElementById('progressDayButton'),
                    loadCsvButton: document.getElementById('loadCsvButton'),
                    saveProgressButton: document.getElementById('saveProgressButton'),
                    loadProgressButton: document.getElementById('loadProgressButton'),
                    exportProgressButton: document.getElementById('exportProgressButton'),
                    csvFileInput: document.getElementById('csvFileInput'),
                    progressFileInput: document.getElementById('progressFileInput'),
                    taskList: document.getElementById('taskList'),
                    startTaskButton: document.getElementById('startTaskButton'),
                    wordDisplay: document.getElementById('wordDisplay'),
                    meaningDisplay: document.getElementById('meaningDisplay'),
                    filterButtons: document.getElementById('filterButtons'),
                    pButton: document.getElementById('pButton'),
                    qButton: document.getElementById('qButton'),
                    knowButton: document.getElementById('knowButton'),
                    memorizedButton: document.getElementById('memorizedButton'),
                    filterTimer: document.getElementById('filterTimer'),
                    pauseButton: document.getElementById('pauseButton'),
                    stopButton: document.getElementById('stopButton'),
                    statusBar: document.getElementById('statusBar'),
                    wordTimeSelect: document.getElementById('wordTimeSelect'),
                    
                    // 모달 요소들
                    alertModal: document.getElementById('alertModal'),
                    alertTitle: document.getElementById('alertTitle'),
                    alertMessage: document.getElementById('alertMessage'),
                    alertClose: document.getElementById('alertClose'),
                    alertOkButton: document.getElementById('alertOkButton'),
                    
                    confirmModal: document.getElementById('confirmModal'),
                    confirmTitle: document.getElementById('confirmTitle'),
                    confirmMessage: document.getElementById('confirmMessage'),
                    confirmClose: document.getElementById('confirmClose'),
                    confirmOkButton: document.getElementById('confirmOkButton'),
                    confirmCancelButton: document.getElementById('confirmCancelButton')
                };
                
                // 초기 설정
                this.elements.exportProgressButton.style.opacity = 0.5;
                this.elements.exportProgressButton.style.pointerEvents = 'none';
            }
            
            initEventListeners() {
                // --- Day Selector 관련 ---
                this.elements.daySelector.addEventListener('change', () => this.day_selected());
                this.elements.daySelectorUp.addEventListener('click', () => {
                    const currentValue = parseInt(this.elements.daySelector.value);
                    const maxValue = parseInt(this.elements.daySelector.max);
                    if (currentValue < maxValue) {
                        this.elements.daySelector.value = currentValue + 1;
                        this.day_selected();
                    }
                });
                this.elements.daySelectorDown.addEventListener('click', () => {
                    const currentValue = parseInt(this.elements.daySelector.value);
                    if (currentValue > 1) {
                        this.elements.daySelector.value = currentValue - 1;
                        this.day_selected();
                    }
                });
                this.elements.progressDayButton.addEventListener('click', () => this.progress_to_next_day());
                
                // --- 파일 관련 ---
                this.elements.loadCsvButton.addEventListener('click', () => this.elements.csvFileInput.click());
                this.elements.csvFileInput.addEventListener('change', (e) => this.load_csv_file(e.target.files[0]));
                this.elements.saveProgressButton.addEventListener('click', () => this.save_progress());
                this.elements.loadProgressButton.addEventListener('click', () => this.elements.progressFileInput.click());
                this.elements.progressFileInput.addEventListener('change', (e) => this.load_progress_file(e.target.files[0]));
                this.elements.exportProgressButton.addEventListener('click', () => this.export_progress());
                
                // --- 작업 관련 ---
                this.elements.taskList.addEventListener('click', (e) => {
                    const taskItem = e.target.closest('.task-item');
                    if (taskItem) {
                        const taskItems = this.elements.taskList.querySelectorAll('.task-item');
                        taskItems.forEach(item => item.classList.remove('selected'));
                        taskItem.classList.add('selected');
                        this.elements.startTaskButton.disabled = false;
                    }
                });
                this.elements.startTaskButton.addEventListener('click', () => this.start_selected_task());
                
                // --- 세션 제어 ---
                this.elements.pauseButton.addEventListener('click', () => this.toggle_pause());
                this.elements.stopButton.addEventListener('click', () => this.stop_session());
                
                // --- 필터링 버튼 ---
                this.elements.pButton.addEventListener('click', () => this.handle_filter_choice(true, 'P'));
                this.elements.qButton.addEventListener('click', () => this.handle_filter_choice(true, 'Q'));
                this.elements.knowButton.addEventListener('click', () => this.handle_filter_choice(false, 'Know'));
                this.elements.memorizedButton.addEventListener('click', () => this.mark_as_memorized());
                
                // --- 설정 관련 ---
                this.elements.wordTimeSelect.addEventListener('change', () => {
                    this.word_display_time_sec = parseFloat(this.elements.wordTimeSelect.value);
                    this.save_progress();
                });
                
                // --- 모달 관련 ---
                this.elements.alertClose.addEventListener('click', () => this.elements.alertModal.style.display = 'none');
                this.elements.alertOkButton.addEventListener('click', () => this.elements.alertModal.style.display = 'none');
                
                this.elements.confirmClose.addEventListener('click', () => this.elements.confirmModal.style.display = 'none');
                this.elements.confirmCancelButton.addEventListener('click', () => this.elements.confirmModal.style.display = 'none');
                
                // 창 닫을 때 저장
                window.addEventListener('beforeunload', (e) => {
                    if (this.all_words.length > 0) {
                        e.preventDefault();
                        e.returnValue = '변경 내용이 저장되지 않을 수 있습니다. 학습 내용을 저장하시겠습니까?';
                    }
                });
            }
            
            // --- 핵심 로직 메서드 ---
            
            progress_to_next_day() {
                if (this.session_running) {
                    this.showAlert("작업 중", "학습 또는 분류 작업 중에는 날짜를 진행할 수 없습니다.");
                    return;
                }
                this.current_day += 1;
                this.elements.daySelector.value = this.current_day;
                this.day_selected();
                this.save_progress();
                console.log(`진행: Day ${this.current_day}`);
            }
            
            get_tasks_for_day(day) {
                const tasks = [];
                const active_sets = {};
                
                // 1. 기존 세트들의 상태 확인 및 작업 추가
                for (const [set_key, set_data] of Object.entries(this.sets)) {
                    const status = set_data.status || 'new';
                    if (status === 'mastered_set') {
                        continue; // 완료된 세트는 건너뜀
                    }
                    
                    const start_day = set_data.start_day || -1;
                    const p_filter_day = set_data.p_filter_day;
                    const q_filter_day = set_data.q_filter_day;
                    const days_since_start = start_day > 0 ? day - start_day : -1;
                    const days_since_p_filter = p_filter_day ? day - p_filter_day : -1;
                    const days_since_q_filter = q_filter_day ? day - q_filter_day : -1;
                    
                    active_sets[set_key] = status;
                    
                    // -- 학습 (Learn) 단계 --
                    if (status === 'new' && start_day === day) {
                        tasks.push({type: 'learn', set: set_key, desc: `${set_key}: 첫 학습 (Day ${day})`});
                    } else if (status === 'learning') {
                        if (days_since_start === 1 || days_since_start === 2) { // Day 2, Day 3 복습
                            tasks.push({type: 'learn', set: set_key, desc: `${set_key}: 복습 (${days_since_start + 1}일차, Day ${day})`});
                        } else if (days_since_start === 3) { // Day 4 에 P 분류
                            tasks.push({type: 'p_filter', set: set_key, desc: `${set_key}: P 분류 진행 (Day ${day})`});
                        }
                    }
                    
                    // -- P 그룹 학습 (Learn P) 단계 --
                    else if (status === 'p_learning') {
                        if (p_filter_day) {
                            const days_since_p_start = day - p_filter_day;
                            if (days_since_p_start === 1 || days_since_p_start === 2) { // P 분류 다음날, 다다음날 복습 (Day 5, 6)
                                if (set_data.p_candidates && set_data.p_candidates.length > 0) {
                                    tasks.push({type: 'learn_p', set: set_key, desc: `${set_key}(P): 복습 (${days_since_p_start + 1}일차, Day ${day})`});
                                }
                            } else if (days_since_p_start === 3) { // P 분류 3일 후 Q 분류 (Day 7)
                                if (set_data.p_candidates && set_data.p_candidates.length > 0) {
                                    tasks.push({type: 'q_filter', set: set_key, desc: `${set_key}(P): Q 분류 진행 (Day ${day})`});
                                } else { // P 후보 없으면 Q 분류 건너뛰고 바로 Q 학습 단계로 (Q 후보 0)
                                    console.log(`${set_key}: P그룹 단어 없어 Q분류 건너뜀 (Day ${day}). Q Learning 상태로 변경 시도.`);
                                    set_data.status = 'q_learning';
                                    set_data.q_filter_day = day;
                                    set_data.q_candidates = [];
                                }
                            }
                        } else {
                            console.log(`경고: ${set_key}가 p_learning 상태지만 p_filter_day가 없습니다.`);
                        }
                    }
                    
                    // -- Q 그룹 학습 (Learn Q) 단계 --
                    else if (status === 'q_learning') {
                        if (q_filter_day) {
                            if (set_data.q_candidates && set_data.q_candidates.length > 0) {
                                tasks.push({type: 'learn_q', set: set_key, desc: `${set_key}(Q): 복습 (Day ${day})`});
                            } else {
                                console.log(`${set_key}: Q그룹 단어 없어 복습 건너뜀 (Day ${day}). 세트 마스터 처리 시도.`);
                                this.mark_set_as_mastered(set_key);
                            }
                        } else {
                            console.log(`경고: ${set_key}가 q_learning 상태지만 q_filter_day가 없습니다.`);
                        }
                    }
                }
                
                // 2. 새로운 세트 시작 조건 확인
                const num_total_words = this.all_words.length;
                const max_possible_sets = num_total_words > 0 ? Math.ceil(num_total_words / WORDS_PER_SET) : 0;
                let current_max_set_num = 0;
                
                if (Object.keys(this.sets).length > 0) {
                    const set_numbers = Object.keys(this.sets)
                        .filter(k => k.startsWith('D') && /^\d+$/.test(k.substring(1)))
                        .map(k => parseInt(k.substring(1)));
                    
                    if (set_numbers.length > 0) {
                        current_max_set_num = Math.max(...set_numbers);
                    }
                }
                
                const next_set_num = current_max_set_num + 1;
                
                if (next_set_num <= max_possible_sets) {
                    const next_set_key = `D${next_set_num}`;
                    if (!active_sets[next_set_key] && day === next_set_num) {
                        tasks.push({type: 'prepare_new_set', set: next_set_key, desc: `${next_set_key}: 학습 시작 준비 (Day ${day})`});
                    }
                }
                
                // 추가 복습 규칙 적용
                // Day 4: D1(P) 복습 추가
                if (day === 4 && this.sets['D1'] && this.sets['D1'].status === 'p_learning' && this.sets['D1'].p_candidates && this.sets['D1'].p_candidates.length > 0) {
                    if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D1')) {
                        tasks.push({type: 'learn_p', set: 'D1', desc: `D1(P): 추가 복습 (Day ${day})`});
                    }
                }
                // Day 5: D1(P), D2(P) 복습 추가
                else if (day === 5) {
                    if (this.sets['D1'] && this.sets['D1'].status === 'p_learning' && this.sets['D1'].p_candidates && this.sets['D1'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D1')) {
                            tasks.push({type: 'learn_p', set: 'D1', desc: `D1(P): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D2'] && this.sets['D2'].status === 'p_learning' && this.sets['D2'].p_candidates && this.sets['D2'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D2')) {
                            tasks.push({type: 'learn_p', set: 'D2', desc: `D2(P): 추가 복습 (Day ${day})`});
                        }
                    }
                }
                // Day 6: D2(P), D3(P) 복습 추가
                else if (day === 6) {
                    if (this.sets['D2'] && this.sets['D2'].status === 'p_learning' && this.sets['D2'].p_candidates && this.sets['D2'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D2')) {
                            tasks.push({type: 'learn_p', set: 'D2', desc: `D2(P): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D3'] && this.sets['D3'].status === 'p_learning' && this.sets['D3'].p_candidates && this.sets['D3'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D3')) {
                            tasks.push({type: 'learn_p', set: 'D3', desc: `D3(P): 추가 복습 (Day ${day})`});
                        }
                    }
                }
                // Day 7: D1(Q), D3(P), D4(P) 복습 추가
                else if (day === 7) {
                    if (this.sets['D1'] && this.sets['D1'].status === 'q_learning' && this.sets['D1'].q_candidates && this.sets['D1'].q_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_q' && t.set === 'D1')) {
                            tasks.push({type: 'learn_q', set: 'D1', desc: `D1(Q): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D3'] && this.sets['D3'].status === 'p_learning' && this.sets['D3'].p_candidates && this.sets['D3'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D3')) {
                            tasks.push({type: 'learn_p', set: 'D3', desc: `D3(P): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D4'] && this.sets['D4'].status === 'p_learning' && this.sets['D4'].p_candidates && this.sets['D4'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D4')) {
                            tasks.push({type: 'learn_p', set: 'D4', desc: `D4(P): 추가 복습 (Day ${day})`});
                        }
                    }
                }
                // Day 8: D2(Q), D4(P), D5(P) 복습 추가
                else if (day === 8) {
                    if (this.sets['D2'] && this.sets['D2'].status === 'q_learning' && this.sets['D2'].q_candidates && this.sets['D2'].q_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_q' && t.set === 'D2')) {
                            tasks.push({type: 'learn_q', set: 'D2', desc: `D2(Q): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D4'] && this.sets['D4'].status === 'p_learning' && this.sets['D4'].p_candidates && this.sets['D4'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D4')) {
                            tasks.push({type: 'learn_p', set: 'D4', desc: `D4(P): 추가 복습 (Day ${day})`});
                        }
                    }
                    if (this.sets['D5'] && this.sets['D5'].status === 'p_learning' && this.sets['D5'].p_candidates && this.sets['D5'].p_candidates.length > 0) {
                        if (!tasks.some(t => t.type === 'learn_p' && t.set === 'D5')) {
                            tasks.push({type: 'learn_p', set: 'D5', desc: `D5(P): 추가 복습 (Day ${day})`});
                        }
                    }
                }
                
                // 정렬: learn -> p_filter -> q_filter -> learn_p -> learn_q -> prepare 순서 + 세트 번호 순서
                const taskTypeOrder = {
                    'learn': 0,
                    'p_filter': 1,
                    'q_filter': 2,
                    'learn_p': 3,
                    'learn_q': 4,
                    'prepare_new_set': 5
                };
                
                tasks.sort((a, b) => {
                    const typeOrderA = taskTypeOrder[a.type] || 6;
                    const typeOrderB = taskTypeOrder[b.type] || 6;
                    
                    if (typeOrderA !== typeOrderB) {
                        return typeOrderA - typeOrderB;
                    }
                    
                    const setNumA = a.set.startsWith('D') && /^\d+$/.test(a.set.substring(1)) ? 
                        parseInt(a.set.substring(1)) : 999;
                    const setNumB = b.set.startsWith('D') && /^\d+$/.test(b.set.substring(1)) ? 
                        parseInt(b.set.substring(1)) : 999;
                    
                    return setNumA - setNumB;
                });
                
                // 중복 제거
                const uniqueTasks = [];
                const seenTasks = new Set();
                
                for (const task of tasks) {
                    const taskKey = `${task.type}_${task.set}`;
                    if (!seenTasks.has(taskKey)) {
                        uniqueTasks.push(task);
                        seenTasks.add(taskKey);
                    }
                }
                
                return uniqueTasks;
            }
            
            update_task_list() {
                const selectedDay = parseInt(this.elements.daySelector.value);
                const tasks = this.get_tasks_for_day(selectedDay);
                
                // 기존 작업 목록 비우기
                this.elements.taskList.innerHTML = '';
                
                if (tasks.length === 0) {
                    const emptyItem = document.createElement('div');
                    emptyItem.className = 'task-item';
                    emptyItem.textContent = `Day ${selectedDay}: 예정된 작업 없음`;
                    emptyItem.style.color = 'grey';
                    this.elements.taskList.appendChild(emptyItem);
                    this.elements.startTaskButton.disabled = true;
                } else {
                    tasks.forEach(task => {
                        const taskItem = document.createElement('div');
                        taskItem.className = 'task-item';
                        taskItem.textContent = task.desc;
                        taskItem.dataset.type = task.type;
                        taskItem.dataset.set = task.set;
                        this.elements.taskList.appendChild(taskItem);
                    });
                    this.elements.startTaskButton.disabled = true;
                }
            }
            
            start_selected_task() {
                if (this.session_running) {
                    this.showAlert("작업 중", "이미 다른 작업이 진행 중입니다.");
                    return;
                }
                
                const selectedTaskItem = this.elements.taskList.querySelector('.task-item.selected');
                if (!selectedTaskItem) {
                    this.showAlert("작업 선택", "시작할 작업을 목록에서 선택해주세요.");
                    return;
                }
                
                // 선택된 작업이 '예정된 작업 없음' 메시지인지 확인
                if (selectedTaskItem.textContent.includes('예정된 작업 없음')) {
                    this.showAlert("작업 선택", "유효한 작업을 선택해주세요.");
                    return;
                }
                
                const taskType = selectedTaskItem.dataset.type;
                const setKey = selectedTaskItem.dataset.set;
                const selectedDay = parseInt(this.elements.daySelector.value);
                
                // 현재 날짜를 선택된 날짜로 업데이트 (미래 날짜 작업 시)
                if (selectedDay > this.current_day) {
                    this.current_day = selectedDay;
                    console.log(`현재 날짜를 Day ${this.current_day}로 업데이트합니다.`);
                }
                
                // 'prepare_new_set' 처리
                if (taskType === 'prepare_new_set') {
                    this.prepare_new_set(setKey, selectedDay);
                    return; // 세션 시작 아님
                }
                
                // --- 실제 세션 시작 ---
                const setData = this.sets[setKey];
                if (!setData) {
                    this.showAlert("오류", `${setKey} 데이터 초기화 오류. CSV를 다시 로드하거나 확인해주세요.`);
                    return;
                }
                
                this.current_set_key = setKey;
                this.current_session_type = taskType;
                
                // 대상 단어 목록 결정
                let word_ids_for_session = [];
                let is_filtering_session = false;
                
                if (taskType === 'learn') {
                    // 첫 학습 시 'new' -> 'learning', start_day 설정
                    if (setData.status === 'new') {
                        setData.status = 'learning';
                        setData.start_day = selectedDay;
                        console.log(`${setKey} 학습 시작 (Day ${selectedDay})`);
                    }
                    word_ids_for_session = setData.word_ids || [];
                    // 학습 시에는 전체 마스터된 단어 제외
                    word_ids_for_session = word_ids_for_session.filter(wid => !this.mastered_all_ids.has(wid));
                }
                else if (taskType === 'learn_p') {
                    word_ids_for_session = setData.p_candidates || [];
                    word_ids_for_session = word_ids_for_session.filter(wid => !this.mastered_all_ids.has(wid));
                }
                else if (taskType === 'learn_q') {
                    word_ids_for_session = setData.q_candidates || [];
                    word_ids_for_session = word_ids_for_session.filter(wid => !this.mastered_all_ids.has(wid));
                }
                else if (taskType === 'p_filter') {
                    // P 분류 조건 확인
                    const expected_p_filter_day = (setData.start_day || -1) + 3;
                    if (!(setData.status === 'learning' && selectedDay === expected_p_filter_day)) {
                        this.showAlert("P 분류 불가", `${setKey}는 Day ${expected_p_filter_day}에 P 분류가 가능합니다. (현재 Day ${selectedDay})`);
                        return;
                    }
                    // P 필터링 대상: 세트 전체 단어 중 아직 마스터 안된 단어
                    this.current_filter_candidates = Array.from(
                        new Set(setData.word_ids || []).difference(this.mastered_all_ids)
                    );
                    is_filtering_session = true;
                }
                else if (taskType === 'q_filter') {
                    // Q 분류 조건 확인
                    const p_filter_day = setData.p_filter_day;
                    if (!p_filter_day) {
                        this.showAlert("Q 분류 오류", `${setKey}의 P 분류 완료일(p_filter_day)이 기록되지 않았습니다.`);
                        return;
                    }
                    const expected_q_filter_day = p_filter_day + 3;
                    if (!(setData.status === 'p_learning' && selectedDay === expected_q_filter_day)) {
                        this.showAlert("Q 분류 불가", `${setKey}는 Day ${expected_q_filter_day}에 Q 분류가 가능합니다. (현재 Day ${selectedDay})`);
                        return;
                    }
                    // Q 필터링 대상: P 후보 단어 중 아직 마스터 안된 단어
                    this.current_filter_candidates = Array.from(
                        new Set(setData.p_candidates || []).difference(this.mastered_all_ids)
                    );
                    is_filtering_session = true;
                }
                
                // 세션 시작
                if (is_filtering_session) {
                    if (this.current_filter_candidates.length === 0) {
                        this.showAlert("정보", `${taskType === 'p_filter' ? 'P' : 'Q'} 분류 대상 단어가 없습니다. (모두 암기되었거나 이전 단계에서 제외됨)`);
                        this.complete_filtering(true); // 후보 없이 완료됨을 알림
                        return;
                    }
                    this.shuffle(this.current_filter_candidates);
                    this.start_filtering_session();
                } else { // 학습 세션
                    // 실제 단어 데이터 가져오기
                    this.current_word_list = word_ids_for_session
                        .map(id => this.get_word_by_id(id))
                        .filter(word => word !== undefined);
                    
                    if (this.current_word_list.length === 0) {
                        this.showAlert("정보", `${this.get_session_type_korean()} 대상 단어가 없습니다. (모두 암기됨)`);
                        this.reset_session_state();
                        // 세트 완료 처리 로직 추가
                        if (taskType === 'learn_q') {
                            this.mark_set_as_mastered(setKey);
                        }
                        return;
                    }
                    this.shuffle(this.current_word_list);
                    this.start_learning_session();
                }
            }
            
            prepare_new_set(set_key, start_day) {
                if (this.sets[set_key]) {
                    this.showAlert("정보", `${set_key}는 이미 준비되었거나 진행 중입니다.`);
                    // 이미 있으면 start_day만 업데이트
                    if (this.sets[set_key].status === 'new' && this.sets[set_key].start_day === -1) {
                        this.sets[set_key].start_day = start_day;
                        console.log(`${set_key}의 시작 예정일을 Day ${start_day}로 설정합니다.`);
                        this.update_task_list();
                        this.save_progress();
                    }
                    return;
                }
                
                try {
                    const set_num = parseInt(set_key.substring(1));
                    const word_start_index = (set_num - 1) * WORDS_PER_SET;
                    const word_end_index = Math.min(word_start_index + WORDS_PER_SET, this.all_words.length);
                    const set_word_ids = this.all_words.slice(word_start_index, word_end_index).map(w => w.id);
                    
                    if (set_word_ids.length === 0) {
                        this.showAlert("오류", `${set_key}에 해당하는 단어가 없습니다. CSV 파일을 확인하세요.`);
                        return;
                    }
                    
                    this.sets[set_key] = {
                        word_ids: set_word_ids,
                        status: 'new',
                        start_day: start_day,
                        p_candidates: [],
                        q_candidates: [],
                        mastered_in_set: [],
                        p_filter_day: null,
                        q_filter_day: null
                    };
                    
                    this.showAlert("세트 준비 완료", `${set_key} 학습이 Day ${start_day}부터 시작될 예정입니다.`);
                    this.update_task_list();
                    this.save_progress();
                } catch (e) {
                    this.showAlert("세트 준비 오류", `${set_key} 준비 중 오류: ${e.message}`);
                }
            }
            
            start_learning_session() {
                if (this.current_word_list.length === 0) {
                    this.showAlert("학습 완료", "학습할 단어가 없습니다.");
                    this.reset_session_state();
                    return;
                }
                
                console.log(`--- ${this.current_set_key} ${this.get_session_type_korean()} 시작 ---`);
                this.session_running = true;
                this.session_paused = false;
                this.current_word_index = -1; // 시작 시 -1로 초기화
                this.update_ui_for_session(true, false);
                this.show_next_word(); // 첫 단어 표시 시작
            }
            
            start_filtering_session() {
                if (this.current_filter_candidates.length === 0) {
                    this.showAlert("분류 완료", `${this.get_session_type_korean()} 대상 단어가 없습니다.`);
                    this.complete_filtering(true); // 후보 없이 완료
                    return;
                }
                
                console.log(`--- ${this.current_set_key} ${this.get_session_type_korean()} 시작 ---`);
                this.session_running = true;
                this.session_paused = false;
                this.current_word_index = -1; // 시작 시 -1로 초기화
                this.current_filter_temp_keep = []; // 새 필터링 세션 시작 시 초기화
                this.update_ui_for_session(true, true);
                this.show_next_filter_word(); // 첫 단어 표시 시작
            }
            
            update_ui_for_session(session_active, is_filtering) {
                // 버튼 상태 설정
                const button_state = session_active ? false : true; // disabled 속성을 설정하므로 반전
                const disabled_state = !button_state;
                const pause_resume_text = this.session_paused ? "계속" : "일시정지";
                
                // 세션 제어 버튼
                this.elements.pauseButton.disabled = button_state;
                this.elements.pauseButton.textContent = pause_resume_text;
                this.elements.stopButton.disabled = button_state;
                
                // 세션 중 비활성화할 컨트롤
                this.elements.daySelector.disabled = session_active;
                this.elements.daySelectorUp.disabled = session_active;
                this.elements.daySelectorDown.disabled = session_active;
                this.elements.progressDayButton.disabled = session_active;
                this.elements.loadCsvButton.parentElement.style.pointerEvents = session_active ? 'none' : 'auto';
                this.elements.saveProgressButton.parentElement.style.pointerEvents = session_active ? 'none' : 'auto';
                this.elements.loadProgressButton.parentElement.style.pointerEvents = session_active ? 'none' : 'auto';
                this.elements.exportProgressButton.parentElement.style.pointerEvents = session_active ? 'none' : 'auto';
                this.elements.taskList.style.pointerEvents = session_active ? 'none' : 'auto';
                this.elements.startTaskButton.disabled = session_active;
                
                // 필터링 버튼 표시/숨김 및 상태 관리
                if (is_filtering && session_active) {
                    this.elements.filterButtons.classList.remove('hidden');
                    // 현재 필터 타입에 맞는 버튼만 활성화
                    this.elements.pButton.disabled = this.current_session_type !== 'p_filter';
                    this.elements.qButton.disabled = this.current_session_type !== 'q_filter';
                    this.elements.knowButton.disabled = false; // '앎' 버튼은 항상 활성화
                    this.elements.memorizedButton.disabled = true; // 필터링 중에는 암기완료 직접 사용 안 함
                    this.elements.meaningDisplay.classList.add('hidden'); // 필터링 시 뜻은 단어와 함께 표시되므로 숨김
                } else if (!is_filtering && session_active) { // 일반 학습 중
                    this.elements.filterButtons.classList.remove('hidden');
                    this.elements.filterTimer.textContent = ''; // 타이머 숨김
                    this.elements.pButton.disabled = true;
                    this.elements.qButton.disabled = true;
                    this.elements.knowButton.disabled = true;
                    this.elements.memorizedButton.disabled = false; // 학습 중 암기완료 버튼 활성화
                    this.elements.meaningDisplay.classList.add('hidden'); // 뜻은 타이머에 따라 표시될 것
                } else { // 세션 비활성 시
                    this.elements.filterButtons.classList.add('hidden');
                    this.elements.wordDisplay.textContent = '';
                    this.elements.meaningDisplay.textContent = '';
                    this.elements.meaningDisplay.classList.add('hidden');
                    this.update_status_bar();
                    this.update_task_list();
                    
                    // 선택된 작업이 있으면 시작 버튼 활성화
                    const selectedTask = this.elements.taskList.querySelector('.task-item.selected');
                    this.elements.startTaskButton.disabled = !selectedTask || selectedTask.textContent.includes('예정된 작업 없음');
                }
                
                // 단어 표시 시간 설정 비활성화/활성화
                this.elements.wordTimeSelect.disabled = session_active;
            }
            
            show_next_word() {
                if (this.session_paused || !this.session_running) return;
                this.cancel_timers(); // 이전 타이머 클리어
                
                this.current_word_index += 1; // 다음 단어로 인덱스 이동
                
                if (this.current_word_index >= this.current_word_list.length) {
                    this.complete_learning_session(); // 세션 완료 처리
                    return;
                }
                
                const word_data = this.current_word_list[this.current_word_index];
                this.elements.wordDisplay.textContent = word_data.word;
                this.elements.meaningDisplay.classList.add('hidden'); // 뜻 숨기기
                this.update_session_status();
                
                // 1. 단어만 표시 (X초)
                this.timer_word_delay = setTimeout(() => this.schedule_meaning_appearance(), 
                    this.word_display_time_sec * 1000);
            }
            
            schedule_meaning_appearance() {
                if (this.session_paused || !this.session_running) return;
                this.timer_word_delay = null; // 타이머 만료
                
                // 2. 뜻 표시 전 딜레이 (1.5초)
                this.timer_meaning_delay = setTimeout(() => this._actually_show_meaning(), 
                    this.meaning_delay_sec * 1000);
            }
            
            _actually_show_meaning() {
                // 타이머 실행 시점에 세션이 종료/일시정지 되거나 인덱스가 범위를 벗어났으면 중단
                if (this.session_paused || !this.session_running || 
                    this.current_word_index >= this.current_word_list.length) {
                    this.timer_meaning_delay = null;
                    return;
                }
                
                this.timer_meaning_delay = null; // 타이머 만료
                
                const word_data = this.current_word_list[this.current_word_index];
                this.elements.meaningDisplay.textContent = word_data.meaning;
                this.elements.meaningDisplay.classList.remove('hidden'); // 뜻 표시
                
                // 3. 뜻 표시 유지 시간 (2초) 후 다음 단어로 이동 예약
                this.timer_next_word = setTimeout(() => this.show_next_word(), 
                    this.meaning_show_sec * 1000);
            }
            
            complete_learning_session() {
                this.cancel_timers();
                this.showAlert("학습 완료", `${this.current_set_key} 세트 (${this.get_session_type_korean()}) 1회 학습 완료.`);
                
                // 특정 조건에서 세트 마스터 처리
                if (this.current_session_type === 'learn_q') {
                    const setData = this.sets[this.current_set_key];
                    if (setData && (!setData.q_candidates || setData.q_candidates.length === 0)) {
                        this.mark_set_as_mastered(this.current_set_key);
                    }
                }
                
                this.reset_session_state();
                this.save_progress();
            }
            
            show_next_filter_word() {
                if (this.session_paused || !this.session_running) return;
                this.cancel_timers(); // 이전 타이머 클리어
                
                this.current_word_index += 1; // 다음 단어로 이동
                
                if (this.current_word_index >= this.current_filter_candidates.length) {
                    this.complete_filtering(); // 모든 후보 분류 완료
                    return;
                }
                
                const word_id = this.current_filter_candidates[this.current_word_index];
                const word_data = this.get_word_by_id(word_id);
                
                if (!word_data) {
                    console.log(`경고: ID ${word_id} 단어 데이터 없음. 건너뜁니다.`);
                    setTimeout(() => this.show_next_filter_word(), 10); // 바로 다음 단어 시도
                    return;
                }
                
                // 단어와 뜻을 함께 표시
                this.elements.wordDisplay.textContent = `${word_data.word}\n\n${word_data.meaning}`;
                this.elements.meaningDisplay.classList.add('hidden'); // 하단 뜻 레이블은 사용 안 함
                this.update_session_status();
                
                // 분류 버튼 활성화
                this.update_ui_for_session(true, true);
                
                // 3초 타임아웃 시작
                this.filter_start_time = Date.now();
                this.is_waiting_for_filter_choice = true;
                this.update_filter_timer();
                
                // 타임아웃 시 자동으로 '앎(Know)'으로 처리
                this.timer_filter_timeout = setTimeout(
                    () => this.handle_filter_choice(false, 'Timeout'), 
                    FILTER_TIMEOUT_SEC * 1000
                );
            }
            
            update_filter_timer() {
                if (!this.session_running || this.session_paused || !this.is_waiting_for_filter_choice) {
                    this.elements.filterTimer.textContent = '';
                    return;
                }
                
                const elapsed = (Date.now() - this.filter_start_time) / 1000;
                const remaining = Math.max(0, FILTER_TIMEOUT_SEC - elapsed);
                this.elements.filterTimer.textContent = `${remaining.toFixed(1)} 초`;
                
                if (remaining > 0) {
                    // 0.1초마다 업데이트
                    setTimeout(() => this.update_filter_timer(), 100);
                }
            }
            
            handle_filter_choice(keep, choice) {
                if (!this.session_running || !this.is_waiting_for_filter_choice) return;
                
                this.is_waiting_for_filter_choice = false; // 선택했으므로 대기 상태 해제
                
                // 타임아웃 타이머 취소
                if (this.timer_filter_timeout) {
                    clearTimeout(this.timer_filter_timeout);
                    this.timer_filter_timeout = null;
                }
                this.elements.filterTimer.textContent = ''; // 타이머 라벨 초기화
                
                // 버튼 비활성화
                this.elements.pButton.disabled = true;
                this.elements.qButton.disabled = true;
                this.elements.knowButton.disabled = true;
                
                if (this.current_word_index < this.current_filter_candidates.length) {
                    const word_id = this.current_filter_candidates[this.current_word_index];
                    if (keep) {
                        // '모름/헷갈림 (P 또는 Q)' 선택 시 임시 목록에 추가
                        this.current_filter_temp_keep.push(word_id);
                        console.log(`[Filter ${this.current_session_type}] Word ID ${word_id}: Kept as ${choice}`);
                    } else {
                        // '앎' 선택 또는 타임아웃 시
                        const action = choice === 'Timeout' ? "Timeout" : "Known";
                        console.log(`[Filter ${this.current_session_type}] Word ID ${word_id}: Discarded (${action})`);
                    }
                }
                
                // 다음 단어 표시 (약간의 딜레이 후)
                setTimeout(() => this.show_next_filter_word(), 200);
            }
            
            complete_filtering(no_candidates = false) {
                const selectedDay = parseInt(this.elements.daySelector.value);
                
                if (no_candidates) { // 분류할 후보가 처음부터 없었던 경우
                    console.log(`${this.current_set_key}: ${this.get_session_type_korean()} 대상 단어 없음.`);
                    const setData = this.sets[this.current_set_key];
                    if (!setData) {
                        this.reset_session_state();
                        return;
                    }
                    
                    // 상태 업데이트
                    if (this.current_session_type === 'p_filter') {
                        setData.status = 'p_learning';
                        setData.p_filter_day = selectedDay;
                        setData.p_candidates = [];
                        console.log(`${this.current_set_key}: P 후보 없이 P Learning 상태로 변경 (Day ${selectedDay}).`);
                    } else if (this.current_session_type === 'q_filter') {
                        setData.status = 'q_learning';
                        setData.q_filter_day = selectedDay;
                        setData.q_candidates = [];
                        console.log(`${this.current_set_key}: Q 후보 없이 Q Learning 상태로 변경됨 (Day ${selectedDay}) -> 즉시 세트 마스터 처리 시도.`);
                        this.mark_set_as_mastered(this.current_set_key);
                    }
                    
                    this.reset_session_state();
                    this.save_progress();
                    return;
                }
                
                // --- 후보가 있었던 경우의 처리 ---
                console.log(`--- ${this.current_set_key} ${this.get_session_type_korean()} 완료 ---`);
                console.log(`유지 단어 (Keep): ${this.current_filter_temp_keep.length}개`);
                
                const setData = this.sets[this.current_set_key];
                if (!setData) {
                    this.showAlert("오류", `${this.current_set_key} 데이터 오류 발생`);
                    this.reset_session_state();
                    return;
                }
                
                const kept_ids = new Set(this.current_filter_temp_keep);
                const original_candidate_ids = new Set(this.current_filter_candidates);
                const discarded_ids = Array.from(
                    new Set([...original_candidate_ids].filter(id => !kept_ids.has(id)))
                );
                
                if (this.current_session_type === 'p_filter') {
                    setData.p_candidates = [...kept_ids];
                    setData.status = 'p_learning';
                    setData.p_filter_day = selectedDay;
                    
                    // P 필터링에서 제외된 단어는 세트 내에서는 마스터된 것으로 간주
                    if (!setData.mastered_in_set) setData.mastered_in_set = [];
                    setData.mastered_in_set.push(...discarded_ids);
                    setData.mastered_in_set = [...new Set(setData.mastered_in_set)]; // 중복 제거
                    
                    let info_msg = `${this.current_set_key}: P 분류 완료.\nP 그룹 단어: ${kept_ids.size}개`;
                    if (kept_ids.size === 0) {
                        console.log(`${this.current_set_key}: P 필터링 후 남은 단어 없음.`);
                        info_msg += "\n(모든 단어가 P 그룹에서 제외되었습니다.)";
                    }
                    this.showAlert("P 분류 완료", info_msg);
                }
                else if (this.current_session_type === 'q_filter') {
                    setData.q_candidates = [...kept_ids];
                    setData.status = 'q_learning';
                    setData.q_filter_day = selectedDay;
                    
                    // Q 필터링에서 제외된 단어는 최종 마스터로 간주
                    let newly_mastered_count = 0;
                    for (const word_id of discarded_ids) {
                        if (!this.mastered_all_ids.has(word_id)) {
                            this.mastered_all_ids.add(word_id);
                            newly_mastered_count++;
                            // 마스터 되었으므로 전체 Q 목록에서도 제거
                            this.q_all_ids.delete(word_id);
                        }
                    }
                    if (newly_mastered_count > 0) {
                        console.log(`${newly_mastered_count}개의 단어가 최종 암기 처리되었습니다.`);
                    }
                    
                    // Q 그룹에 유지된 단어들을 전체 Q 목록에 업데이트
                    // 먼저 기존 세트의 Q 단어들을 전체 Q 목록에서 제거
                    const q_ids_before_update = new Set(setData.q_candidates || []);
                    for (const id of q_ids_before_update) {
                        this.q_all_ids.delete(id);
                    }
                    // 새로 유지된 Q 단어들을 전체 Q 목록에 추가
                    for (const id of kept_ids) {
                        this.q_all_ids.add(id);
                    }
                    
                    let info_msg = `${this.current_set_key}: Q 분류 완료.\nQ 그룹 단어: ${kept_ids.size}개`;
                    
                    // Q 필터링 후 남은 단어가 없으면 세트 마스터 처리
                    if (kept_ids.size === 0) {
                        console.log(`${this.current_set_key}: Q 필터링 후 남은 단어 없음. 세트 마스터 처리 시도.`);
                        this.mark_set_as_mastered(this.current_set_key);
                        info_msg += "\n(모든 단어가 Q 그룹에서 제외되어 세트가 완료되었습니다.)";
                    }
                    this.showAlert("Q 분류 완료", info_msg);
                }
                
                this.reset_session_state();
                this.save_progress();
            }
            
            mark_as_memorized() {
                if (!this.session_running || this.session_paused || 
                    this.current_session_type.endsWith('_filter')) {
                    return; // 학습 세션 중에만 가능
                }
                
                if (this.current_word_index < 0 || 
                    this.current_word_index >= this.current_word_list.length) {
                    return; // 유효하지 않은 인덱스
                }
                
                const word_data = this.current_word_list[this.current_word_index];
                const word_id = word_data.id;
                
                if (this.mastered_all_ids.has(word_id)) {
                    console.log(`Word ID ${word_id} 는 이미 암기 완료 상태입니다.`);
                    // 이미 암기된 단어는 바로 다음 단어로 넘어감
                    this.cancel_timers();
                    setTimeout(() => this.show_next_word(), 100);
                    return;
                }
                
                console.log(`[Mastered] Word ID ${word_id}: '${word_data.word}' 암기 완료 처리`);
                this.mastered_all_ids.add(word_id);
                
                // 현재 세트 데이터에서도 P, Q 후보에서 제거
                const setData = this.sets[this.current_set_key];
                if (setData) {
                    if (setData.p_candidates && setData.p_candidates.includes(word_id)) {
                        setData.p_candidates = setData.p_candidates.filter(id => id !== word_id);
                    }
                    if (setData.q_candidates && setData.q_candidates.includes(word_id)) {
                        setData.q_candidates = setData.q_candidates.filter(id => id !== word_id);
                    }
                    // mastered_in_set 에도 추가
                    if (!setData.mastered_in_set) setData.mastered_in_set = [];
                    setData.mastered_in_set.push(word_id);
                    setData.mastered_in_set = [...new Set(setData.mastered_in_set)]; // 중복 제거
                }
                
                // 전체 Q 목록에서도 제거
                this.q_all_ids.delete(word_id);
                
                // 암기 처리 후에는 현재 단어 표시/타이머 중단하고 다음 단어로 즉시 이동
                this.cancel_timers();
                
                this.update_status_bar(); // 마스터 카운트 업데이트
                this.save_progress();     // 변경사항 저장
                
                // 다음 단어 즉시 표시
                setTimeout(() => this.show_next_word(), 100);
            }
            
            mark_set_as_mastered(set_key) {
                const setData = this.sets[set_key];
                if (setData && setData.status !== 'mastered_set') {
                    console.log(`--- 세트 ${set_key} 학습 완료! ---`);
                    setData.status = 'mastered_set';
                    
                    // 세트의 모든 단어를 최종 마스터 목록에 추가
                    const all_ids_in_set = new Set(setData.word_ids || []);
                    let newly_mastered_count = 0;
                    
                    for (const word_id of all_ids_in_set) {
                        if (!this.mastered_all_ids.has(word_id)) {
                            this.mastered_all_ids.add(word_id);
                            newly_mastered_count++;
                            // 마스터 처리 시 Q 목록에서도 제거
                            this.q_all_ids.delete(word_id);
                        }
                    }
                    
                    if (newly_mastered_count > 0) {
                        console.log(`세트 완료 처리 중 ${newly_mastered_count}개 단어 추가 암기 완료됨.`);
                    }
                    
                    // 세트가 마스터되면 Q 목록에서는 해당 세트 단어 확실히 제거
                    for (const id of all_ids_in_set) {
                        this.q_all_ids.delete(id);
                    }
                    
                    // 세트 내 후보 목록 클리어
                    setData.p_candidates = [];
                    setData.q_candidates = [];
                    
                    // UI 업데이트
                    this.update_task_list();
                    this.update_status_bar();
                    this.save_progress();
                }
            }
            
            toggle_pause() {
                if (!this.session_running) return;
                
                this.session_paused = !this.session_paused;
                if (this.session_paused) {
                    console.log("--- 세션 일시정지 ---");
                    this.elements.pauseButton.textContent = "계속";
                    this.update_session_status();
                    // 진행 중이던 타이머 멈춤
                    this.cancel_timers();
                    if (this.is_waiting_for_filter_choice) {
                        this.elements.filterTimer.textContent = "Paused";
                    }
                } else { // Resume
                    console.log("--- 세션 계속 ---");
                    this.elements.pauseButton.textContent = "일시정지";
                    this.update_session_status();
                    
                    // 중단된 시점에 따라 타이머 재개 또는 다음 단계 진행
                    if (this.is_waiting_for_filter_choice) {
                        console.log(`필터 타이머 재개: ${FILTER_TIMEOUT_SEC}초`);
                        this.filter_start_time = Date.now();
                        this.update_filter_timer();
                        this.timer_filter_timeout = setTimeout(
                            () => this.handle_filter_choice(false, 'Timeout'), 
                            FILTER_TIMEOUT_SEC * 1000
                        );
                    } else if (this.current_session_type.endsWith('_filter')) {
                        // 필터링은 다음 단어 표시부터 다시
                        setTimeout(() => this.show_next_filter_word(), 100);
                    } else {
                        // 학습은 다음 단어 표시부터 다시
                        setTimeout(() => this.show_next_word(), 100);
                    }
                }
            }
            
            stop_session() {
                if (!this.session_running) return;
                
                console.log("--- 세션 중지 ---");
                this.session_running = false;
                this.session_paused = false;
                this.is_waiting_for_filter_choice = false;
                this.cancel_timers();
                this.reset_session_state();
                this.showAlert("세션 중단", "현재 진행중인 작업을 중단했습니다.");
                this.save_progress();
            }
            
            cancel_timers() {
                // 모든 타이머 취소
                if (this.timer_word_delay) {
                    clearTimeout(this.timer_word_delay);
                    this.timer_word_delay = null;
                }
                if (this.timer_meaning_delay) {
                    clearTimeout(this.timer_meaning_delay);
                    this.timer_meaning_delay = null;
                }
                if (this.timer_next_word) {
                    clearTimeout(this.timer_next_word);
                    this.timer_next_word = null;
                }
                if (this.timer_filter_timeout) {
                    clearTimeout(this.timer_filter_timeout);
                    this.timer_filter_timeout = null;
                }
                
                // 타이머 라벨도 초기화
                this.elements.filterTimer.textContent = '';
            }
            
            reset_session_state() {
                this.session_running = false;
                this.session_paused = false;
                this.is_waiting_for_filter_choice = false;
                this.current_session_type = null;
                this.current_set_key = null;
                this.current_word_list = [];
                this.current_word_index = -1;
                this.current_filter_candidates = [];
                this.current_filter_temp_keep = [];
                this.cancel_timers();
                this.update_ui_for_session(false);
                this.update_task_list();
                this.update_status_bar();
            }
            
            // --- UI 업데이트 및 헬퍼 메서드 ---
            
            update_status_bar() {
                const total_words = this.all_words.length;
                const mastered_count = this.mastered_all_ids.size;
                const q_count = this.q_all_ids.size;
                
                let status_text = `총 단어: ${total_words} | 암기 완료: ${mastered_count} | Q 그룹: ${q_count} | 현황: 준비됨 | Day: ${this.current_day}`;
                
                if (this.session_running) {
                    const session_name = this.get_session_type_korean();
                    const set_key_str = this.current_set_key || "?";
                    const current_num = this.current_word_index + 1;
                    let total_in_session = 0;
                    
                    if (this.current_session_type.endsWith("_filter")) {
                        total_in_session = this.current_filter_candidates.length;
                    } else { // learn, learn_p, learn_q
                        total_in_session = this.current_word_list.length;
                    }
                    
                    status_text = `총: ${total_words} | 암기: ${mastered_count} | Q: ${q_count} | 작업: ${set_key_str} ${session_name} (${current_num}/${total_in_session}) | Day: ${this.current_day}`;
                    
                    if (this.session_paused) {
                        status_text += " (일시정지됨)";
                    }
                }
                
                this.elements.statusBar.textContent = status_text;
            }
            
            update_session_status() {
                this.update_status_bar();
            }
            
            get_session_type_korean() {
                const type_map = {
                    'learn': "학습",
                    'p_filter': "P 분류",
                    'q_filter': "Q 분류",
                    'learn_p': "P 그룹 학습",
                    'learn_q': "Q 그룹 학습",
                    'prepare_new_set': "새 세트 준비"
                };
                return type_map[this.current_session_type] || "알 수 없음";
            }
            
            day_selected() {
                if (this.session_running) {
                    return; // 세션 중 변경 불가
                }
                
                // 입력 검증
                let day = parseInt(this.elements.daySelector.value);
                if (isNaN(day) || day < 1) {
                    day = 1;
                    this.elements.daySelector.value = 1;
                }
                
                const maxDay = parseInt(this.elements.daySelector.max);
                if (day > maxDay) {
                    day = maxDay;
                    this.elements.daySelector.value = maxDay;
                }
                
                // 선택된 날짜에 맞춰 작업 목록 업데이트
                this.update_task_list();
                this.update_status_bar();
            }
            
            update_day_selector() {
                let max_day_in_config = this.current_day;
                let max_day_needed = max_day_in_config;
                
                // 로드된 세트들의 상태를 기반으로 필요한 최대 일차 계산
                if (Object.keys(this.sets).length > 0) {
                    for (const setData of Object.values(this.sets)) {
                        let est_end = setData.start_day || 0;
                        if (est_end > 0) {
                            est_end += 7; // 대략적인 예상 (P 3일 + Q 3일 + 여유 1일)
                            if (setData.q_filter_day) est_end = Math.max(est_end, setData.q_filter_day + 5);
                            else if (setData.p_filter_day) est_end = Math.max(est_end, setData.p_filter_day + 5);
                            max_day_needed = Math.max(max_day_needed, est_end);
                        }
                    }
                }
                
                // 모든 세트가 시작될 날짜까지는 포함
                const num_total_words = this.all_words.length;
                const max_possible_sets = num_total_words > 0 ? Math.ceil(num_total_words / WORDS_PER_SET) : 0;
                if (max_possible_sets > 0) {
                    max_day_needed = Math.max(max_day_needed, max_possible_sets + 7);
                }
                
                this.elements.daySelector.max = Math.max(1, max_day_needed);
                this.elements.daySelector.value = this.current_day;
                
                // 작업 목록 다시 로드
                this.update_task_list();
            }
            
            get_word_by_id(word_id) {
                // 캐시 사용 성능 개선
                if (!this._word_dict_cache[word_id]) {
                    for (const word of this.all_words) {
                        if (word.id === word_id) {
                            this._word_dict_cache[word_id] = word;
                            break;
                        }
                    }
                }
                return this._word_dict_cache[word_id];
            }
            
            // --- 파일 입출력 메서드 ---
            
            load_csv_file(file) {
                if (this.session_running) {
                    this.showAlert("작업 중", "학습 또는 분류 작업 중에는 CSV 파일을 불러올 수 없습니다.");
                    return;
                }
                
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const csv_content = event.target.result;
                        const new_words = [];
                        
                        // CSV 파싱
                        const lines = csv_content.split(/\r\n|\n/);
                        let has_header = false;
                        
                        // 헤더 감지 및 처리
                        if (lines.length > 0) {
                            const first_row = this.parse_csv_line(lines[0]);
                            if (first_row.length >= 2) {
                                const col1 = first_row[0].trim().toLowerCase();
                                const col2 = first_row[1].trim().toLowerCase();
                                if (col1.includes('word') && (col2.includes('meaning') || col2.includes('mean'))) {
                                    has_header = true;
                                } else if (first_row[0].trim() && first_row[1].trim()) {
                                    new_words.push({
                                        id: 0,
                                        word: first_row[0].trim(),
                                        meaning: first_row[1].trim()
                                    });
                                }
                            }
                        }
                        
                        // 나머지 줄 읽기
                        let start_id = new_words.length; // 헤더 아니었던 첫 줄 포함 시 id=1부터 시작하도록
                        for (let i = has_header ? 1 : 0; i < lines.length; i++) {
                            if (!lines[i].trim()) continue; // 빈 줄 건너뛰기
                            
                            const row = this.parse_csv_line(lines[i]);
                            if (row.length >= 2 && row[0].trim() && row[1].trim()) {
                                const word = row[0].trim();
                                const meaning = row[1].trim();
                                new_words.push({
                                    id: start_id + (i - (has_header ? 1 : 0)),
                                    word: word,
                                    meaning: meaning
                                });
                            } else {
                                console.log(`경고: CSV 파일 ${i + 1}번째 줄 데이터 형식 오류 또는 빈 데이터 무시: ${lines[i]}`);
                            }
                        }
                        
                        if (new_words.length === 0) {
                            this.showAlert("오류", "CSV 파일에서 유효한 단어 데이터를 읽지 못했습니다.");
                            return;
                        }
                        
                        // 기존 데이터 초기화 여부 확인
                        if (this.all_words.length > 0) {
                            this.showConfirm(
                                "확인",
                                "기존 학습 데이터가 있습니다. 새로 불러오면 기존 데이터가 초기화됩니다. 계속하시겠습니까?",
                                () => this.processCsvData(new_words, file.name)
                            );
                        } else {
                            this.processCsvData(new_words, file.name);
                        }
                        
                    } catch (e) {
                        this.showAlert("CSV 읽기 오류", `CSV 파일을 읽는 중 오류가 발생했습니다:\n${e.message}`);
                    }
                };
                
                reader.onerror = () => {
                    this.showAlert("파일 읽기 오류", "파일을 읽는 중 오류가 발생했습니다.");
                };
                
                reader.readAsText(file);
            }
            
            processCsvData(new_words, filename) {
                // 데이터 초기화 및 로드
                this.all_words = new_words;
                this.sets = {};
                this.mastered_all_ids = new Set();
                this.q_all_ids = new Set();
                this.current_day = 1; // 새 파일 로드 시 1일차부터 시작
                this.elements.daySelector.value = this.current_day;
                this._word_dict_cache = {}; // 캐시 초기화
                
                // 100개씩 세트 나누기
                const num_words = this.all_words.length;
                const num_sets = Math.ceil(num_words / WORDS_PER_SET);
                
                // 세트 데이터 생성
                for (let i = 0; i < num_sets; i++) {
                    const set_key = `D${i+1}`;
                    const start_index = i * WORDS_PER_SET;
                    const end_index = Math.min((i + 1) * WORDS_PER_SET, num_words);
                    const set_word_ids = this.all_words.slice(start_index, end_index).map(w => w.id);
                    
                    // 세트 초기 데이터 설정
                    this.sets[set_key] = {
                        word_ids: set_word_ids,
                        status: 'new',
                        start_day: -1, // prepare 시점에 설정됨
                        p_candidates: [],
                        q_candidates: [],
                        mastered_in_set: [],
                        p_filter_day: null,
                        q_filter_day: null
                    };
                    
                    // 첫번째 세트(D1)는 시작 예정일을 1일로 설정
                    if (i === 0) {
                        this.sets[set_key].start_day = 1;
                    }
                }
                
                this.showAlert("불러오기 완료", `${filename}에서 총 ${num_words}개의 단어를 불러와 ${num_sets}개의 세트로 나누었습니다.`);
                
                // 내보내기 메뉴 활성화
                this.elements.exportProgressButton.style.opacity = 1;
                this.elements.exportProgressButton.style.pointerEvents = 'auto';
                
                this.update_day_selector();
                this.update_status_bar();
                this.save_progress(); // 새로 로드 후 상태 저장
            }
            
            // CSV 라인 파싱 (간단한 구현)
            parse_csv_line(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"' && (i === 0 || line[i-1] !== '\\')) {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current); // 마지막 필드 추가
                return result;
            }
            
            save_progress() {
                if (this.all_words.length === 0) return; // 저장할 단어가 없으면 스킵
                
                try {
                    const progress_data = {
                        saved_at: new Date().toISOString(),
                        all_words: this.all_words,
                        sets: this.sets,
                        mastered_all_ids: Array.from(this.mastered_all_ids),
                        q_all_ids: Array.from(this.q_all_ids),
                        current_day: this.current_day,
                        word_display_time_sec: this.word_display_time_sec,
                        meaning_delay_sec: this.meaning_delay_sec,
                        meaning_show_sec: this.meaning_show_sec
                    };
                    
                    // 데이터를 JSON으로 변환
                    const jsonStr = JSON.stringify(progress_data);
                    
                    // JSON 파일로 저장
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vocab_progress_day${this.current_day}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(`학습 내용 저장 완료: ${new Date().toLocaleTimeString()}`);
                    
                    // 현재 URL에 데이터 저장하여 공유 가능하게 만들기
                    this.updateUrlWithData(jsonStr);
                    
                } catch (e) {
                    console.error(`저장 오류: ${e.message}`);
                    this.showAlert("저장 오류", `학습 내용을 저장하는 중 오류가 발생했습니다:\n${e.message}`);
                }
            }
            
            // URL에 데이터 저장 (공유 가능한 링크 생성)
            updateUrlWithData(jsonStr) {
                try {
                    // 데이터를 인코딩하여 URL 해시로 설정
                    const encodedData = encodeURIComponent(jsonStr);
                    // 현재 URL의 파라미터 부분과 함께 업데이트
                    const baseUrl = window.location.href.split('#')[0];
                    const newUrl = baseUrl + (baseUrl.includes('?') ? '&' : '?') + 'autoload=true#' + encodedData;
                    
                    // 클립보드에 복사 가능한 짧은 URL 표시 (URL이 너무 길어서 직접 복사는 어려움)
                    console.log('공유 가능한 URL이 생성되었습니다. 다른 사람과 공유하려면 이 링크를 사용하세요.');
                    
                    // 현재 페이지 URL 히스토리 업데이트 (새로고침해도 데이터 유지)
                    window.history.replaceState(null, document.title, newUrl);
                } catch (e) {
                    console.error('URL 업데이트 오류:', e);
                    // 실패해도 주요 기능에 영향 없으므로 사용자에게 알리지 않음
                }
            }
            
            load_progress_file(file) {
                if (this.session_running) {
                    this.showAlert("작업 중", "학습 또는 분류 작업 중에는 설정 파일을 불러올 수 없습니다.");
                    return;
                }
                
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const jsonStr = event.target.result;
                        this.loadProgressData(jsonStr);
                    } catch (e) {
                        this.showAlert("불러오기 오류", `파일을 읽는 중 오류가 발생했습니다: ${e.message}`);
                    }
                };
                
                reader.onerror = () => {
                    this.showAlert("파일 읽기 오류", "파일을 읽는 중 오류가 발생했습니다.");
                };
                
                reader.readAsText(file);
            }
            
            loadProgressData(jsonStr) {
                try {
                    const progress_data = JSON.parse(jsonStr);
                    
                    // 데이터 유효성 검사 (기본 필드 확인)
                    if (!progress_data.all_words || !Array.isArray(progress_data.all_words)) {
                        throw new Error("유효하지 않은 학습 데이터 형식입니다.");
                    }
                    
                    this.all_words = progress_data.all_words || [];
                    // ID가 없는 구 버전 데이터 호환성 처리
                    if (this.all_words.length > 0 && !('id' in this.all_words[0])) {
                        this.all_words.forEach((word, i) => {
                            word.id = i;
                        });
                    }
                    
                    this.sets = progress_data.sets || {};
                    this.mastered_all_ids = new Set(progress_data.mastered_all_ids || []);
                    this.q_all_ids = new Set(progress_data.q_all_ids || []);
                    this.current_day = progress_data.current_day || 1;
                    this.word_display_time_sec = progress_data.word_display_time_sec || DEFAULT_WORD_TIME_SEC;
                    this.meaning_delay_sec = progress_data.meaning_delay_sec || MEANING_DELAY_SEC;
                    this.meaning_show_sec = progress_data.meaning_show_sec || MEANING_SHOW_SEC;
                    this._word_dict_cache = {}; // 캐시 초기화
                    
                    this.elements.daySelector.value = this.current_day;
                    this.elements.wordTimeSelect.value = this.word_display_time_sec.toString();
                    
                    // 내보내기 메뉴 활성화
                    if (this.all_words.length > 0) {
                        this.elements.exportProgressButton.style.opacity = 1;
                        this.elements.exportProgressButton.style.pointerEvents = 'auto';
                    }
                    
                    this.update_day_selector();
                    this.update_status_bar();
                    this.update_task_list();
                    
                    // 현재 URL에 데이터 저장
                    this.updateUrlWithData(jsonStr);
                    
                    this.showAlert("불러오기 완료", "학습 내용을 성공적으로 불러왔습니다.");
                } catch (e) {
                    console.error(`불러오기 오류: ${e.message}`);
                    this.showAlert("불러오기 오류", `저장된 학습 내용을 불러오는 중 오류가 발생했습니다: ${e.message}`);
                    this.initialize_empty_state();
                }
            }
            
            initialize_empty_state() {
                this.all_words = [];
                this.sets = {};
                this.mastered_all_ids = new Set();
                this.q_all_ids = new Set();
                this.current_day = 1;
                this.word_display_time_sec = DEFAULT_WORD_TIME_SEC;
                this.meaning_delay_sec = MEANING_DELAY_SEC;
                this.meaning_show_sec = MEANING_SHOW_SEC;
                this._word_dict_cache = {};
                
                this.elements.daySelector.value = this.current_day;
                this.elements.exportProgressButton.style.opacity = 0.5;
                this.elements.exportProgressButton.style.pointerEvents = 'none';
                
                this.update_day_selector();
                this.update_status_bar();
                this.update_task_list();
            }
            
            export_progress() {
                if (this.all_words.length === 0) {
                    this.showAlert("내보내기 불가", "내보낼 단어 데이터가 없습니다. 먼저 CSV 파일을 불러오세요.");
                    return;
                }
                
                try {
                    const export_rows = [];
                    // 헤더 작성
                    export_rows.push(['WordID', 'Word', 'Meaning', 'Overall_Status', 'Set', 'Set_Status', 'Is_P_Candidate', 'Is_Q_Candidate']);
                    
                    // 모든 단어 순회하며 상태 정보 기록
                    for (const word_data of this.all_words) {
                        const word_id = word_data.id;
                        let overall_status = "Unknown";
                        let set_name = "N/A";
                        let set_status = "N/A";
                        let is_p = false;
                        let is_q = false;
                        
                        // 1. 전체 마스터 여부 확인
                        if (this.mastered_all_ids.has(word_id)) {
                            overall_status = "Mastered";
                        }
                        // 2. 전체 Q 그룹 소속 여부 확인 (마스터되지 않았을 경우)
                        else if (this.q_all_ids.has(word_id)) {
                            overall_status = "Q-Group";
                            is_q = true;
                        }
                        
                        // 3. 단어가 속한 세트 및 세트 내 상태 찾기
                        let found_in_set = false;
                        for (const [s_key, s_data] of Object.entries(this.sets)) {
                            if (s_data.word_ids && s_data.word_ids.includes(word_id)) {
                                set_name = s_key;
                                set_status = s_data.status || 'Unknown';
                                is_p = s_data.p_candidates && s_data.p_candidates.includes(word_id);
                                
                                // 세트 내 Q 후보 상태
                                const is_q_in_set = s_data.q_candidates && s_data.q_candidates.includes(word_id);
                                if (is_q_in_set && overall_status !== "Mastered") {
                                    overall_status = "Q-Group";
                                    is_q = true;
                                } else if (is_p && overall_status === "Unknown") {
                                    overall_status = "P-Group";
                                }
                                
                                // 세트 내에서 마스터 처리 되었는지
                                if (s_data.mastered_in_set && s_data.mastered_in_set.includes(word_id) && 
                                    !["Mastered", "Q-Group"].includes(overall_status)) {
                                    overall_status = "Known_in_Set";
                                }
                                
                                found_in_set = true;
                                break;
                            }
                        }
                        
                        // overall_status 가 여전히 Unknown이면 기본 상태
                        if (overall_status === "Unknown") {
                            if (set_status === 'new' || set_status === 'learning') {
                                overall_status = "Learning/New";
                            }
                        }
                        
                        export_rows.push([
                            word_id,
                            word_data.word,
                            word_data.meaning,
                            overall_status,
                            set_name,
                            set_status,
                            is_p ? 'Yes' : 'No',
                            is_q ? 'Yes' : 'No'
                        ]);
                    }
                    
                    // CSV 파일 생성
                    let csv_content = export_rows.map(row => 
                        row.map(cell => 
                            typeof cell === 'string' && cell.includes(',') ? 
                            `"${cell.replace(/"/g, '""')}"` : cell
                        ).join(',')
                    ).join('\n');
                    
                    // BOM 추가 (UTF-8 인코딩 표시)
                    const BOM = "\uFEFF";
                    csv_content = BOM + csv_content;
                    
                    // 파일 다운로드
                    const blob = new Blob([csv_content], { type: 'text/csv;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.setAttribute('href', url);
                    a.setAttribute('download', `vocab_export_day${this.current_day}.csv`);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    this.showAlert("내보내기 완료", `현재 학습 상태를 CSV 파일로 저장했습니다.`);
                    
                } catch (e) {
                    this.showAlert("내보내기 오류", `파일을 저장하는 중 오류가 발생했습니다:\n${e.message}`);
                }
            }
            
            // --- 유틸리티 메서드 ---
            
            shuffle(array) {
                // Fisher-Yates 셔플 알고리즘
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // --- 모달 대화상자 메서드 ---
            
            showAlert(title, message, callback) {
                this.elements.alertTitle.textContent = title;
                this.elements.alertMessage.textContent = message;
                this.elements.alertModal.style.display = 'block';
                
                // 콜백 설정 (있을 경우)
                if (callback) {
                    const originalCallback = this.elements.alertOkButton.onclick;
                    this.elements.alertOkButton.onclick = () => {
                        this.elements.alertModal.style.display = 'none';
                        callback();
                        // 원래 콜백 복원
                        this.elements.alertOkButton.onclick = originalCallback;
                    };
                }
            }
            
            showConfirm(title, message, onConfirm, onCancel) {
                this.elements.confirmTitle.textContent = title;
                this.elements.confirmMessage.textContent = message;
                this.elements.confirmModal.style.display = 'block';
                
                // 기존 이벤트 핸들러 백업 및 새 핸들러 설정
                const originalOkCallback = this.elements.confirmOkButton.onclick;
                const originalCancelCallback = this.elements.confirmCancelButton.onclick;
                
                // 확인 버튼 핸들러
                this.elements.confirmOkButton.onclick = () => {
                    this.elements.confirmModal.style.display = 'none';
                    if (onConfirm) onConfirm();
                    // 원래 콜백 복원
                    this.elements.confirmOkButton.onclick = originalOkCallback;
                    this.elements.confirmCancelButton.onclick = originalCancelCallback;
                };
                
                // 취소 버튼 핸들러
                this.elements.confirmCancelButton.onclick = () => {
                    this.elements.confirmModal.style.display = 'none';
                    if (onCancel) onCancel();
                    // 원래 콜백 복원
                    this.elements.confirmOkButton.onclick = originalOkCallback;
                    this.elements.confirmCancelButton.onclick = originalCancelCallback;
                };
            }
        }
        
        // --- 확장 메서드 ---
        
        // Set 객체에 difference 메서드 추가 (Set1 - Set2)
        Set.prototype.difference = function(setB) {
            const diff = new Set(this);
            for (const elem of setB) {
                diff.delete(elem);
            }
            return diff;
        };
        
        // --- 애플리케이션 시작 ---
        document.addEventListener('DOMContentLoaded', () => {
            const app = new VocabLearnerApp();
        });
    </script>
</body>
</html>